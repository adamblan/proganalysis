% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\usepackage[utf8]{inputenc}
\DeclareUnicodeCharacter{00A0}{\nobreakspace}
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{babel}
\usepackage{times}
\usepackage[Sonny]{fncychap}
\usepackage{longtable}
\usepackage{sphinx}
\usepackage{multirow}


\title{Astroid Documentation}
\date{February 26, 2014}
\release{0.24.4}
\author{Logilab S.A.}
\newcommand{\sphinxlogo}{}
\renewcommand{\releasename}{Release}
\makeindex

\makeatletter
\def\PYG@reset{\let\PYG@it=\relax \let\PYG@bf=\relax%
    \let\PYG@ul=\relax \let\PYG@tc=\relax%
    \let\PYG@bc=\relax \let\PYG@ff=\relax}
\def\PYG@tok#1{\csname PYG@tok@#1\endcsname}
\def\PYG@toks#1+{\ifx\relax#1\empty\else%
    \PYG@tok{#1}\expandafter\PYG@toks\fi}
\def\PYG@do#1{\PYG@bc{\PYG@tc{\PYG@ul{%
    \PYG@it{\PYG@bf{\PYG@ff{#1}}}}}}}
\def\PYG#1#2{\PYG@reset\PYG@toks#1+\relax+\PYG@do{#2}}

\expandafter\def\csname PYG@tok@gd\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.63,0.00,0.00}{##1}}}
\expandafter\def\csname PYG@tok@gu\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.50,0.00,0.50}{##1}}}
\expandafter\def\csname PYG@tok@gt\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.27,0.87}{##1}}}
\expandafter\def\csname PYG@tok@gs\endcsname{\let\PYG@bf=\textbf}
\expandafter\def\csname PYG@tok@gr\endcsname{\def\PYG@tc##1{\textcolor[rgb]{1.00,0.00,0.00}{##1}}}
\expandafter\def\csname PYG@tok@cm\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@vg\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@m\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@mh\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@cs\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}\def\PYG@bc##1{\setlength{\fboxsep}{0pt}\colorbox[rgb]{1.00,0.94,0.94}{\strut ##1}}}
\expandafter\def\csname PYG@tok@ge\endcsname{\let\PYG@it=\textit}
\expandafter\def\csname PYG@tok@vc\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@il\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@go\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.20,0.20,0.20}{##1}}}
\expandafter\def\csname PYG@tok@cp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@gi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.63,0.00}{##1}}}
\expandafter\def\csname PYG@tok@gh\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.00,0.50}{##1}}}
\expandafter\def\csname PYG@tok@ni\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.84,0.33,0.22}{##1}}}
\expandafter\def\csname PYG@tok@nl\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.13,0.44}{##1}}}
\expandafter\def\csname PYG@tok@nn\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\expandafter\def\csname PYG@tok@no\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.38,0.68,0.84}{##1}}}
\expandafter\def\csname PYG@tok@na\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@nb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@nc\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\expandafter\def\csname PYG@tok@nd\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.33,0.33,0.33}{##1}}}
\expandafter\def\csname PYG@tok@ne\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@nf\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.49}{##1}}}
\expandafter\def\csname PYG@tok@si\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.44,0.63,0.82}{##1}}}
\expandafter\def\csname PYG@tok@s2\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@vi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@nt\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.45}{##1}}}
\expandafter\def\csname PYG@tok@nv\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@s1\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@gp\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\expandafter\def\csname PYG@tok@sh\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@ow\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@sx\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\expandafter\def\csname PYG@tok@bp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@c1\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@kc\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@c\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@mf\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@err\endcsname{\def\PYG@bc##1{\setlength{\fboxsep}{0pt}\fcolorbox[rgb]{1.00,0.00,0.00}{1,1,1}{\strut ##1}}}
\expandafter\def\csname PYG@tok@kd\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@ss\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.32,0.47,0.09}{##1}}}
\expandafter\def\csname PYG@tok@sr\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.14,0.33,0.53}{##1}}}
\expandafter\def\csname PYG@tok@mo\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@mi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@kn\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@o\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PYG@tok@kr\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@s\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@kp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@w\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.73,0.73}{##1}}}
\expandafter\def\csname PYG@tok@kt\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.56,0.13,0.00}{##1}}}
\expandafter\def\csname PYG@tok@sc\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@sb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@k\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@se\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@sd\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}

\def\PYGZbs{\char`\\}
\def\PYGZus{\char`\_}
\def\PYGZob{\char`\{}
\def\PYGZcb{\char`\}}
\def\PYGZca{\char`\^}
\def\PYGZam{\char`\&}
\def\PYGZlt{\char`\<}
\def\PYGZgt{\char`\>}
\def\PYGZsh{\char`\#}
\def\PYGZpc{\char`\%}
\def\PYGZdl{\char`\$}
\def\PYGZhy{\char`\-}
\def\PYGZsq{\char`\'}
\def\PYGZdq{\char`\"}
\def\PYGZti{\char`\~}
% for compatibility with earlier versions
\def\PYGZat{@}
\def\PYGZlb{[}
\def\PYGZrb{]}
\makeatother

\begin{document}

\maketitle
\tableofcontents
\phantomsection\label{index::doc}


Contents:


\chapter{Inference on the AST in Astroid}
\label{inference:welcome-to-astroid-s-documentation}\label{inference:inference}\label{inference::doc}\label{inference:inference-on-the-ast-in-astroid}

\section{Introduction}
\label{inference:introduction}

\subsection{What/where is `inference' ?}
\label{inference:what-where-is-inference}
Well, not \emph{inference} in general, but inference within \emph{astroid} in
particular... Basically this is extracting information about a node of
the AST from the node's context so as to make its description
richer. For example it can be most useful to know that this
identifier node \emph{toto} can have values among 1, 2.0, and ``yesterday''.

The inference process entry-point is the \code{NodeNG.infer()} method
of the AST nodes which is defined in \code{NodeNG} the base class
for AST nodes. This method return a generator which yields the
successive inference for the node when going through the possible
execution branches.


\subsection{How does it work ?}
\label{inference:how-does-it-work}
\begin{notice}{note}{Todo}

double chek this \code{infer()} is monkey-patched point
\end{notice}

The \code{NodeNG.infer()} method either delegates the actual inference
to the instance specific method \code{NodeNG.\_explicit\_inference()}
when not \emph{None} or to the overloaded \code{\_infer()} method. The
important point to note is that the \code{\_infer()} is \emph{not} defined in
the nodes classes but is instead \emph{monkey-patched} in the
\code{inference.py} so that the inference implementation is not
scattered to the multiple node classes.

\begin{notice}{note}{Note:}
The inference method are to be wrapped in decorators like
\code{path\_wrapper()} which update the inference context.
\end{notice}

In both cases the \code{infer()} returns a \emph{generator} which iterates
through the various \emph{values} the node could take.

\begin{notice}{note}{Todo}

introduce the {\hyperref[inference:inference.infer_end]{\code{inference.infer\_end()}}} method and
terminal nodes along with the recursive call
\end{notice}

In some case the value yielded will not be a node found in the AST of the node
but an instance of a special inference class such as \code{\_Yes},
\code{Instance},etc. Those classes are defined in \code{bases.py}.

Namely, the special singleton \code{YES()} is yielded when the inference reaches
a point where t can't follow the code and is so unable to guess a value ; and
instances of the \code{Instance} class are yielded when the current node is
infered to be an instance of some known class.


\subsection{What does it rely upon ?}
\label{inference:what-does-it-rely-upon}
In order to perform such an inference the \code{infer()} methods rely
on several more global objects, mainly :
\begin{description}
\item[{\code{MANAGER}}] \leavevmode
is a unique global instance of the class \code{AstroidManager},
it helps managing and reusing inference needed / done somewhere
else than the current invocation node.

\item[{\code{InferenceContext}}] \leavevmode
Instances of this class can be passed to the \code{infer()} methods
to convey aditionnal information on the context of the current
node, and especially the current scope.

\end{description}

\begin{notice}{note}{Todo}

Write something about \code{Scope} objects and
\code{NodeNG.lookup()} method.
\end{notice}


\section{API documentation}
\label{inference:api-documentation}
Here is the annotaded API documentation extracted from the source code
of the {\hyperref[inference:module-inference]{\code{inference}}}.

\begin{notice}{note}{Todo}

actually annotate the doc to structure its approach
\end{notice}
\phantomsection\label{inference:module-inference}\index{inference (module)}
this module contains a set of functions to handle inference on astroid trees
\index{CallContext (class in inference)}

\begin{fulllineitems}
\phantomsection\label{inference:inference.CallContext}\pysiglinewithargsret{\strong{class }\code{inference.}\bfcode{CallContext}}{\emph{args}, \emph{starargs}, \emph{dstarargs}}{}
when inferring a function call, this class is used to remember values
given as argument
\index{infer\_argument() (inference.CallContext method)}

\begin{fulllineitems}
\phantomsection\label{inference:inference.CallContext.infer_argument}\pysiglinewithargsret{\bfcode{infer\_argument}}{\emph{funcnode}, \emph{name}, \emph{context}}{}
infer a function argument value according to the call context

\end{fulllineitems}


\end{fulllineitems}

\index{infer\_arguments() (in module inference)}

\begin{fulllineitems}
\phantomsection\label{inference:inference.infer_arguments}\pysiglinewithargsret{\code{inference.}\bfcode{infer\_arguments}}{\emph{self}, \emph{context=None}}{}
\end{fulllineitems}

\index{infer\_ass() (in module inference)}

\begin{fulllineitems}
\phantomsection\label{inference:inference.infer_ass}\pysiglinewithargsret{\code{inference.}\bfcode{infer\_ass}}{\emph{self}, \emph{context=None}}{}
infer a AssName/AssAttr: need to inspect the RHS part of the
assign node

\end{fulllineitems}

\index{infer\_augassign() (in module inference)}

\begin{fulllineitems}
\phantomsection\label{inference:inference.infer_augassign}\pysiglinewithargsret{\code{inference.}\bfcode{infer\_augassign}}{\emph{self}, \emph{context=None}}{}
\end{fulllineitems}

\index{infer\_binop() (in module inference)}

\begin{fulllineitems}
\phantomsection\label{inference:inference.infer_binop}\pysiglinewithargsret{\code{inference.}\bfcode{infer\_binop}}{\emph{self}, \emph{context=None}}{}
\end{fulllineitems}

\index{infer\_callfunc() (in module inference)}

\begin{fulllineitems}
\phantomsection\label{inference:inference.infer_callfunc}\pysiglinewithargsret{\code{inference.}\bfcode{infer\_callfunc}}{\emph{self}, \emph{context=None}}{}
infer a CallFunc node by trying to guess what the function returns

\end{fulllineitems}

\index{infer\_empty\_node() (in module inference)}

\begin{fulllineitems}
\phantomsection\label{inference:inference.infer_empty_node}\pysiglinewithargsret{\code{inference.}\bfcode{infer\_empty\_node}}{\emph{self}, \emph{context=None}}{}
\end{fulllineitems}

\index{infer\_end() (in module inference)}

\begin{fulllineitems}
\phantomsection\label{inference:inference.infer_end}\pysiglinewithargsret{\code{inference.}\bfcode{infer\_end}}{\emph{self}, \emph{context=None}}{}
inference's end for node such as Module, Class, Function, Const...

\end{fulllineitems}

\index{infer\_from() (in module inference)}

\begin{fulllineitems}
\phantomsection\label{inference:inference.infer_from}\pysiglinewithargsret{\code{inference.}\bfcode{infer\_from}}{\emph{self}, \emph{context=None}, \emph{asname=True}}{}
infer a From nodes: return the imported module/object

\end{fulllineitems}

\index{infer\_getattr() (in module inference)}

\begin{fulllineitems}
\phantomsection\label{inference:inference.infer_getattr}\pysiglinewithargsret{\code{inference.}\bfcode{infer\_getattr}}{\emph{self}, \emph{context=None}}{}
infer a Getattr node by using getattr on the associated object

\end{fulllineitems}

\index{infer\_global() (in module inference)}

\begin{fulllineitems}
\phantomsection\label{inference:inference.infer_global}\pysiglinewithargsret{\code{inference.}\bfcode{infer\_global}}{\emph{self}, \emph{context=None}}{}
\end{fulllineitems}

\index{infer\_import() (in module inference)}

\begin{fulllineitems}
\phantomsection\label{inference:inference.infer_import}\pysiglinewithargsret{\code{inference.}\bfcode{infer\_import}}{\emph{self}, \emph{context=None}, \emph{asname=True}}{}
infer an Import node: return the imported module/object

\end{fulllineitems}

\index{infer\_index() (in module inference)}

\begin{fulllineitems}
\phantomsection\label{inference:inference.infer_index}\pysiglinewithargsret{\code{inference.}\bfcode{infer\_index}}{\emph{self}, \emph{context=None}}{}
\end{fulllineitems}

\index{infer\_name() (in module inference)}

\begin{fulllineitems}
\phantomsection\label{inference:inference.infer_name}\pysiglinewithargsret{\code{inference.}\bfcode{infer\_name}}{\emph{self}, \emph{context=None}}{}
infer a Name: use name lookup rules

\end{fulllineitems}

\index{infer\_name\_module() (in module inference)}

\begin{fulllineitems}
\phantomsection\label{inference:inference.infer_name_module}\pysiglinewithargsret{\code{inference.}\bfcode{infer\_name\_module}}{\emph{self}, \emph{name}}{}
\end{fulllineitems}

\index{infer\_subscript() (in module inference)}

\begin{fulllineitems}
\phantomsection\label{inference:inference.infer_subscript}\pysiglinewithargsret{\code{inference.}\bfcode{infer\_subscript}}{\emph{self}, \emph{context=None}}{}
infer simple subscription such as {[}1,2,3{]}{[}0{]} or (1,2,3){[}-1{]}

\end{fulllineitems}

\index{infer\_unaryop() (in module inference)}

\begin{fulllineitems}
\phantomsection\label{inference:inference.infer_unaryop}\pysiglinewithargsret{\code{inference.}\bfcode{infer\_unaryop}}{\emph{self}, \emph{context=None}}{}
\end{fulllineitems}



\chapter{Extending Astroid Syntax Tree}
\label{extending::doc}\label{extending:extending-astroid-syntax-tree}
Sometimes Astroid will miss some potentially important information
users may wish to add, for instance with the standard library
\emph{hashlib} module. In some other cases, users may want to customize the
way inference works, for instance to explain Astroid that calls to
\emph{collections.namedtuple} are returning a class with some known
attributes.

Modifications in the AST are now possible using the using the generic
transformation API. You can find examples in the \emph{brain/}
subdirectory, which are taken from the the \href{https://bitbucket.org/logilab/pylint-brain}{pylint-brain} project.

Transformation functions are registered using the \emph{register\_transform} method of
the Astroid manager:
\index{register\_transform() (astroid.manager.AstroidManager method)}

\begin{fulllineitems}
\phantomsection\label{extending:astroid.manager.AstroidManager.register_transform}\pysiglinewithargsret{\code{AstroidManager.}\bfcode{register\_transform}}{\emph{node\_class}, \emph{transform}, \emph{predicate=None}}{}
Register \emph{transform(node)} function to be applied on the given
Astroid's \emph{node\_class} if \emph{predicate} is None or return a true value
when called with the node as argument.

The transform function may return a value which is then used to
substitute the original node in the tree.

\end{fulllineitems}


To add filtering based on the \emph{as\_string} representation of the node
in addition to the type, the {\hyperref[extending:astroid.AsStringRegexpPredicate]{\code{astroid.AsStringRegexpPredicate}}}
predicate object can be used.
\index{AsStringRegexpPredicate (class in astroid)}

\begin{fulllineitems}
\phantomsection\label{extending:astroid.AsStringRegexpPredicate}\pysiglinewithargsret{\strong{class }\code{astroid.}\bfcode{AsStringRegexpPredicate}}{\emph{regexp}, \emph{expression=None}}{}
Class to be used as predicate that may be given to \emph{register\_transform}

First argument is a regular expression that will be searched against the \emph{as\_string}
representation of the node onto which it's applied.

If specified, the second argument is an \emph{attrgetter} expression that will be
applied on the node first to get the actual node on which \emph{as\_string} should
be called.

\end{fulllineitems}


Last but not least, the \code{inference\_tip()} function is there to register
a custom inference function.
\index{inference\_tip() (in module astroid)}

\begin{fulllineitems}
\phantomsection\label{extending:astroid.inference_tip}\pysiglinewithargsret{\code{astroid.}\bfcode{inference\_tip}}{\emph{infer\_function}}{}
Given an instance specific inference function, return a function to be
given to MANAGER.register\_transform to set this inference function.

Typical usage

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{MANAGER}\PYG{o}{.}\PYG{n}{register\PYGZus{}transform}\PYG{p}{(}\PYG{n}{CallFunc}\PYG{p}{,} \PYG{n}{inference\PYGZus{}tip}\PYG{p}{(}\PYG{n}{infer\PYGZus{}named\PYGZus{}tuple}\PYG{p}{)}\PYG{p}{,}
                           \PYG{n}{AsStringRegexpPredicate}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{namedtuple}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{func}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{)}
\end{Verbatim}

\end{fulllineitems}



\chapter{Indices and tables}
\label{index:pylint-brain}\label{index:indices-and-tables}\begin{itemize}
\item {} 
\emph{genindex}

\item {} 
\emph{modindex}

\item {} 
\emph{search}

\end{itemize}


\renewcommand{\indexname}{Python Module Index}
\begin{theindex}
\def\bigletter#1{{\Large\sffamily#1}\nopagebreak\vspace{1mm}}
\bigletter{i}
\item {\texttt{inference}}, \pageref{inference:module-inference}
\end{theindex}

\renewcommand{\indexname}{Index}
\printindex
\end{document}
